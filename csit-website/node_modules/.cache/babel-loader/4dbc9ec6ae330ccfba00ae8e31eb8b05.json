{"ast":null,"code":"var _jsxFileName = \"E:\\\\INTERNSHIPFILES\\\\CodingFolder\\\\csit-website\\\\src\\\\Components\\\\MainMap.js\";\nimport React from 'react';\nimport mapboxgl from 'mapbox-gl';\nmapboxgl.accessToken = 'pk.eyJ1IjoiYXF1YWltcGFjdCIsImEiOiJja2R0d2N3emswdzlwMnptcGliNTk4ZHNkIn0.jPYEzZD-aErgL25Zx9N_Kg';\nlet map;\nlet counter = 0; // let colorIDs = []\n\nclass MainMap extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      lng: 103.851959,\n      lat: 1.290270,\n      zoom: 9.5\n    };\n    this.mapContainer = React.createRef();\n  }\n\n  componentDidMount() {\n    import('./map.css').then(() => {\n      map = new mapboxgl.Map({\n        container: this.mapContainer,\n        style: 'mapbox://styles/mapbox/streets-v11',\n        center: [this.state.lng, this.state.lat],\n        zoom: this.state.zoom\n      });\n    }); // if(this.props.profile.length > 0 && this.props.movement.length > 0){\n    //     let mappedResults = this.props.profile.map(x => {\n    //         return({\n    //             profile: x,\n    //             movements: this.props.movement.filter(xx => xx.suspectId == x.id)\n    //         })\n    //     })\n    //     colorIDs = mappedResults.map(x => {\n    //         return(color)\n    //     })\n    // }\n  }\n\n  generateColor() {\n    let n = (Math.random() * 0xfffff * 1000000).toString(16);\n    return '#' + n.slice(0, 6);\n  }\n\n  getDatetime(datetime, selection) {\n    // 20/7/2020 8:00\n    let date = datetime.split(\" \");\n    let fulldate = date[0].split(\"/\");\n    let mon = fulldate[1];\n    let day = fulldate[0];\n    let year = fulldate[2];\n    let fullTime = date[1].split(\":\");\n    let hh = fullTime[0];\n    let min = fullTime[1]; // const monthNames = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n\n    const shortmonthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sept\", \"Oct\", \"Nov\", \"Dec\"];\n    let finalDatetime;\n\n    if (selection === \"d\") {\n      finalDatetime = day + \" \" + shortmonthNames[parseInt(mon) - 1] + \" \" + year;\n    } else if (selection === \"t\") {\n      let timing = \"AM\";\n\n      if (parseInt(hh) === 12) {\n        timing = \"PM\";\n      }\n\n      if (parseInt(hh) > 12) {\n        hh = parseInt(hh) - 12;\n        timing = \"PM\";\n      }\n\n      finalDatetime = hh + \":\" + min + \" \" + timing;\n    } // else if(selection == \"dt\"){\n    //     finalDatetime = new Date(datetime)\n    // }\n\n\n    return finalDatetime;\n  }\n\n  componentDidUpdate() {\n    let that = this;\n\n    if (this.props.profile.length > 0 && this.props.movement.length > 0 && counter !== 1) {\n      // if(IDs.length != 0){\n      //     IDs = []\n      // }\n      // console.log(this.props.profile)\n      // timeformat: [this.convertDate(movement.datetimeEntered),this.convertDate(movement.datetimeLeft)]\n      let mappedResults = this.props.profile.map(x => {\n        return {\n          profile: x,\n          movements: this.props.movement.filter(xx => xx.suspectId === x.id)\n        };\n      }); // Accepts the array and key\n\n      const groupBy = (array, key) => {\n        // Return the end result\n        return array.reduce((result, currentValue) => {\n          // If an array already present for key, push it to the array. Else create an array and push the object\n          (result[currentValue[key]] = result[currentValue[key]] || []).push(currentValue); // Return the current iteration `result` value, this will be taken as next iteration `result` value and accumulate\n\n          return result;\n        }, {}); // empty object is the initial value for result object\n      }; // Group by location address as key to the person array\n\n\n      const personGroupedByColor = groupBy(this.props.movement, 'locationShortaddress');\n      console.log(personGroupedByColor);\n      var UPoints = Object.keys(personGroupedByColor).map(function (key) {\n        if (personGroupedByColor[key].length === 1) {\n          let item = personGroupedByColor[key][0];\n          return {\n            'type': 'Feature',\n            'properties': {\n              'movementID': item.id,\n              'enter': item.datetimeEntered,\n              'leave': item.datetimeLeft,\n              'placeID': item.locationShortaddress,\n              'description': `<strong>${item.locationShortaddress}</strong><p>Time Entered: ${that.getDatetime(item.datetimeEntered, 't')}</p><p>Time Left: ${that.getDatetime(item.datetimeLeft, 't')}</p><p>Date: ${that.getDatetime(item.datetimeLeft, 'd')}</p>`\n            },\n            'geometry': {\n              'type': 'Point',\n              'coordinates': [item.locationLong, item.locationLat]\n            }\n          };\n        } else {\n          let movementID = personGroupedByColor[key].map(x => x.id); // console.log(movementID)\n\n          let enter = personGroupedByColor[key].map(x => x.datetimeEntered);\n          let leave = personGroupedByColor[key].map(x => x.datetimeLeft);\n          let placeID = key;\n          let text = `<strong>${key}</strong>`; // console.log(placeID)\n\n          personGroupedByColor[key].forEach(xx => {\n            let name = that.props.profile.filter(x => x.id === xx.suspectId).map(x => {\n              return x.firstName + \" \" + x.lastName;\n            });\n            text += `<p>${name}</p>`;\n            text += `<p>Time Entered: ${that.getDatetime(xx.datetimeEntered, 't')}</p><p>Time Left: ${that.getDatetime(xx.datetimeLeft, 't')}</p><p>Date: ${that.getDatetime(xx.datetimeLeft, 'd')}</p>`;\n          }); // console.log(text)\n          // let description = `<strong>${item.locationShortaddress}</strong><p>Time Entered: ${that.getDatetime(item.datetimeEntered, 't')}</p><p>Time Left: ${that.getDatetime(item.datetimeLeft, 't')}</p><p>Date: ${that.getDatetime(item.datetimeLeft, 'd')}</p>`\n\n          return {\n            'type': 'Feature',\n            'properties': {\n              'movementID': movementID,\n              'enter': enter,\n              'leave': leave,\n              'placeID': placeID,\n              'description': text\n            },\n            'geometry': {\n              'type': 'Point',\n              'coordinates': [personGroupedByColor[key][0].locationLong, personGroupedByColor[key][0].locationLat]\n            }\n          };\n        }\n      });\n      map.loadImage('https://docs.mapbox.com/mapbox-gl-js/assets/custom_marker.png', // Add an image to use as a custom marker\n      function (error, image) {\n        if (error) throw error;\n        map.addImage('Imgids', image);\n        mappedResults.forEach(e => {\n          let lol = Math.floor(Math.random() * 101).toString();\n          let UMovements = e.movements.map(x => {\n            return [x.locationLong, x.locationLat];\n          });\n          console.log(UMovements);\n          map.addSource(lol, {\n            'type': 'geojson',\n            'data': {\n              'type': 'Feature',\n              'properties': {},\n              'geometry': {\n                'type': 'LineString',\n                'coordinates': UMovements\n              }\n            }\n          });\n          let color = that.generateColor();\n          map.addLayer({\n            'id': lol,\n            'type': 'line',\n            'source': lol,\n            'layout': {\n              'line-join': 'round',\n              'line-cap': 'round'\n            },\n            'paint': {\n              'line-color': color,\n              'line-width': 5\n            }\n          });\n        });\n        map.addSource('placeIDs', {\n          'type': 'geojson',\n          'data': {\n            'type': 'FeatureCollection',\n            'features': UPoints\n          }\n        }); // Add a layer showing the places.\n\n        map.addLayer({\n          'id': 'placeIDs',\n          'type': 'symbol',\n          'source': 'placeIDs',\n          'layout': {\n            // \"line-cap\": \"round\",\n            // \"line-join\": \"round\"\n            'icon-image': 'Imgids',\n            'icon-allow-overlap': true\n          }\n        });\n      }); // Create a popup, but don't add it to the map yet.\n\n      var popup = new mapboxgl.Popup({\n        closeButton: false,\n        closeOnClick: false\n      });\n      map.on('click', 'placeIDs', function (e) {\n        var placeID = e.features[0].properties.placeID;\n        var description = e.features[0].properties.description;\n        var movementID = e.features[0].properties.movementID;\n        var enter = e.features[0].properties.enter;\n        var leave = e.features[0].properties.leave; // count += 1\n        // let m = that.props.movement.filter(x => x.id == movementID)\n        // let p = that.props.profile.filter(x => x.id == m[0].suspectId)\n\n        that.props.dataRetrieved(movementID); // if(Array.isArray(movementID)){\n        // }\n        // console.log(movementID)\n      });\n      map.on('mouseenter', 'placeIDs', function (e) {\n        // Change the cursor style as a UI indicator.\n        map.getCanvas().style.cursor = 'pointer';\n        var coordinates = e.features[0].geometry.coordinates.slice();\n        var description = e.features[0].properties.description; // Ensure that if the map is zoomed out such that multiple\n        // copies of the feature are visible, the popup appears\n        // over the copy being pointed to.\n\n        while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {\n          coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;\n        } // Populate the popup and set its coordinates\n        // based on the feature found.\n\n\n        popup.setLngLat(coordinates).setHTML(description).addTo(map);\n      });\n      map.on('mouseleave', 'placeIDs', function () {\n        map.getCanvas().style.cursor = '';\n        popup.remove();\n      });\n      counter += 1;\n    }\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      style: {\n        position: \"relative\",\n        height: \"700px\",\n        width: \"100%\"\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 316,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      ref: el => this.mapContainer = el,\n      style: {\n        position: \"reletive\",\n        width: \"inherit\",\n        height: \"inherit\"\n      },\n      id: \"map-field\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 317,\n        columnNumber: 17\n      }\n    }));\n  }\n\n}\n\nexport default MainMap;","map":{"version":3,"sources":["E:/INTERNSHIPFILES/CodingFolder/csit-website/src/Components/MainMap.js"],"names":["React","mapboxgl","accessToken","map","counter","MainMap","Component","constructor","props","state","lng","lat","zoom","mapContainer","createRef","componentDidMount","then","Map","container","style","center","generateColor","n","Math","random","toString","slice","getDatetime","datetime","selection","date","split","fulldate","mon","day","year","fullTime","hh","min","shortmonthNames","finalDatetime","parseInt","timing","componentDidUpdate","that","profile","length","movement","mappedResults","x","movements","filter","xx","suspectId","id","groupBy","array","key","reduce","result","currentValue","push","personGroupedByColor","console","log","UPoints","Object","keys","item","datetimeEntered","datetimeLeft","locationShortaddress","locationLong","locationLat","movementID","enter","leave","placeID","text","forEach","name","firstName","lastName","loadImage","error","image","addImage","e","lol","floor","UMovements","addSource","color","addLayer","popup","Popup","closeButton","closeOnClick","on","features","properties","description","dataRetrieved","getCanvas","cursor","coordinates","geometry","abs","lngLat","setLngLat","setHTML","addTo","remove","render","position","height","width","el"],"mappings":"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","sourcesContent":["import React from 'react'\r\nimport mapboxgl from 'mapbox-gl';\r\n\r\nmapboxgl.accessToken = 'pk.eyJ1IjoiYXF1YWltcGFjdCIsImEiOiJja2R0d2N3emswdzlwMnptcGliNTk4ZHNkIn0.jPYEzZD-aErgL25Zx9N_Kg';\r\n\r\nlet map\r\nlet counter = 0\r\n// let colorIDs = []\r\n\r\nclass MainMap extends React.Component{\r\n    \r\n    constructor(props){\r\n        super(props)\r\n\r\n        this.state = {\r\n            lng: 103.851959,\r\n            lat: 1.290270,\r\n            zoom: 9.5,\r\n\r\n        };\r\n\r\n        this.mapContainer = React.createRef();\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        import('./map.css').then(() => {\r\n            map = new mapboxgl.Map({\r\n                container: this.mapContainer,\r\n                style: 'mapbox://styles/mapbox/streets-v11',\r\n                center: [this.state.lng, this.state.lat],\r\n                zoom: this.state.zoom\r\n            });\r\n        })\r\n        \r\n\r\n        // if(this.props.profile.length > 0 && this.props.movement.length > 0){\r\n\r\n        //     let mappedResults = this.props.profile.map(x => {\r\n        //         return({\r\n        //             profile: x,\r\n        //             movements: this.props.movement.filter(xx => xx.suspectId == x.id)\r\n        //         })\r\n        //     })\r\n\r\n        //     colorIDs = mappedResults.map(x => {\r\n        //         return(color)\r\n        //     })\r\n        // }\r\n    }\r\n\r\n    generateColor(){\r\n        let n = (Math.random() * 0xfffff * 1000000).toString(16);\r\n        return '#' + n.slice(0, 6);\r\n    }\r\n\r\n    getDatetime(datetime, selection){\r\n\r\n        // 20/7/2020 8:00\r\n        let date = datetime.split(\" \")\r\n        let fulldate = date[0].split(\"/\")\r\n        \r\n\r\n        let mon = fulldate[1]\r\n        let day = fulldate[0]\r\n        let year = fulldate[2]\r\n        let fullTime = date[1].split(\":\")\r\n        let hh = fullTime[0]\r\n        let min = fullTime[1]\r\n\r\n        // const monthNames = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\r\n        const shortmonthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sept\", \"Oct\", \"Nov\", \"Dec\"];\r\n\r\n        let finalDatetime\r\n        if(selection === \"d\"){\r\n            finalDatetime = day + \" \" + shortmonthNames[parseInt(mon)-1] + \" \" + year\r\n        }\r\n        else if(selection === \"t\"){\r\n            let timing = \"AM\"\r\n            if(parseInt(hh) === 12){\r\n                timing = \"PM\"\r\n            }\r\n            if(parseInt(hh) > 12){\r\n                hh = parseInt(hh) - 12\r\n                timing = \"PM\"\r\n            }\r\n            finalDatetime = hh + \":\" + min + \" \" + timing\r\n        }\r\n        // else if(selection == \"dt\"){\r\n        //     finalDatetime = new Date(datetime)\r\n        // }\r\n        return finalDatetime\r\n    }\r\n\r\n    componentDidUpdate(){\r\n\r\n        let that = this\r\n        if(this.props.profile.length > 0 && this.props.movement.length > 0 && counter !== 1){\r\n            // if(IDs.length != 0){\r\n            //     IDs = []\r\n            // }\r\n\r\n            // console.log(this.props.profile)\r\n\r\n            // timeformat: [this.convertDate(movement.datetimeEntered),this.convertDate(movement.datetimeLeft)]\r\n            let mappedResults = this.props.profile.map(x => {\r\n                return({\r\n                    profile: x,\r\n                    movements: this.props.movement.filter(xx => xx.suspectId === x.id)\r\n                })\r\n            })\r\n\r\n                        // Accepts the array and key\r\n            const groupBy = (array, key) => {\r\n                // Return the end result\r\n                return array.reduce((result, currentValue) => {\r\n                // If an array already present for key, push it to the array. Else create an array and push the object\r\n                (result[currentValue[key]] = result[currentValue[key]] || []).push(\r\n                    currentValue\r\n                );\r\n                // Return the current iteration `result` value, this will be taken as next iteration `result` value and accumulate\r\n                return result;\r\n                }, {}); // empty object is the initial value for result object\r\n            };\r\n            \r\n            // Group by location address as key to the person array\r\n            const personGroupedByColor = groupBy(this.props.movement, 'locationShortaddress');\r\n            \r\n            console.log(personGroupedByColor)\r\n\r\n            var UPoints = Object.keys(personGroupedByColor).map(function(key) {\r\n                if(personGroupedByColor[key].length === 1){\r\n                    let item = personGroupedByColor[key][0]\r\n                    return({\r\n                        'type': 'Feature',\r\n                        'properties': {\r\n                            'movementID':item.id,\r\n                            'enter': item.datetimeEntered,\r\n                            'leave': item.datetimeLeft,\r\n                            'placeID': item.locationShortaddress,\r\n                            'description':\r\n                                `<strong>${item.locationShortaddress}</strong><p>Time Entered: ${that.getDatetime(item.datetimeEntered, 't')}</p><p>Time Left: ${that.getDatetime(item.datetimeLeft, 't')}</p><p>Date: ${that.getDatetime(item.datetimeLeft, 'd')}</p>`\r\n                            },\r\n                        'geometry': {\r\n                            'type': 'Point',\r\n                            'coordinates': [item.locationLong, item.locationLat]\r\n                        }\r\n                    })\r\n                }\r\n                else{\r\n                    let movementID = personGroupedByColor[key].map(x => x.id )\r\n                    // console.log(movementID)\r\n\r\n                    let enter = personGroupedByColor[key].map(x => x.datetimeEntered )\r\n                    let leave = personGroupedByColor[key].map(x => x.datetimeLeft)\r\n                    let placeID = key\r\n\r\n                    let text = `<strong>${key}</strong>`\r\n                    // console.log(placeID)\r\n                    personGroupedByColor[key].forEach(xx => {\r\n                        let name = that.props.profile.filter(x => x.id === xx.suspectId).map(x => {\r\n                            return(x.firstName + \" \" + x.lastName)\r\n                        })\r\n                        text += `<p>${name}</p>`\r\n                        text += `<p>Time Entered: ${that.getDatetime(xx.datetimeEntered, 't')}</p><p>Time Left: ${that.getDatetime(xx.datetimeLeft, 't')}</p><p>Date: ${that.getDatetime(xx.datetimeLeft, 'd')}</p>`\r\n                    })\r\n\r\n                    // console.log(text)\r\n                    // let description = `<strong>${item.locationShortaddress}</strong><p>Time Entered: ${that.getDatetime(item.datetimeEntered, 't')}</p><p>Time Left: ${that.getDatetime(item.datetimeLeft, 't')}</p><p>Date: ${that.getDatetime(item.datetimeLeft, 'd')}</p>`\r\n\r\n                    return({\r\n                        'type': 'Feature',\r\n                        'properties': {\r\n                            'movementID': movementID,\r\n                            'enter': enter,\r\n                            'leave': leave,\r\n                            'placeID': placeID,\r\n                            'description': text,\r\n                            },\r\n                        'geometry': {\r\n                            'type': 'Point',\r\n                            'coordinates': [personGroupedByColor[key][0].locationLong, personGroupedByColor[key][0].locationLat]\r\n                        }\r\n                    })\r\n                }\r\n            });\r\n\r\n            map.loadImage(\r\n                'https://docs.mapbox.com/mapbox-gl-js/assets/custom_marker.png',\r\n                // Add an image to use as a custom marker\r\n                function(error, image) {\r\n                    if (error) throw error;\r\n                    \r\n                    map.addImage('Imgids', image);\r\n                    \r\n                    mappedResults.forEach(e => {\r\n\r\n                        let lol = Math.floor(Math.random() * 101).toString()\r\n\r\n                        let UMovements = e.movements.map(x => {\r\n                            return([x.locationLong, x.locationLat])\r\n                        })\r\n\r\n                        console.log(UMovements)\r\n\r\n                        map.addSource(lol, {\r\n                            'type': 'geojson',\r\n                            'data': {\r\n                                'type': 'Feature',\r\n                                'properties': {},\r\n                                'geometry': {\r\n                                    'type': 'LineString',\r\n                                    'coordinates': UMovements\r\n                                }\r\n                            }\r\n                        });\r\n    \r\n                        let color = that.generateColor()\r\n    \r\n                        map.addLayer({\r\n                            'id': lol,\r\n                            'type': 'line',\r\n                            'source': lol,\r\n                            'layout': {\r\n                                'line-join': 'round',\r\n                                'line-cap': 'round'\r\n                            },\r\n                            'paint': {\r\n                                'line-color': color,\r\n                                'line-width': 5\r\n                            }\r\n                        });\r\n                    })\r\n\r\n                    map.addSource('placeIDs', {\r\n                        'type': 'geojson',\r\n                        'data': {\r\n                            'type': 'FeatureCollection',\r\n                            'features': UPoints\r\n                        }\r\n                    });\r\n                    \r\n                    // Add a layer showing the places.\r\n                    map.addLayer({\r\n                        'id': 'placeIDs',\r\n                        'type': 'symbol',\r\n                        'source': 'placeIDs',\r\n                        'layout': {\r\n                            // \"line-cap\": \"round\",\r\n                            // \"line-join\": \"round\"\r\n                            'icon-image': 'Imgids',\r\n                            'icon-allow-overlap': true\r\n                        }\r\n                    });\r\n    \r\n                });\r\n\r\n            // Create a popup, but don't add it to the map yet.\r\n            var popup = new mapboxgl.Popup({\r\n                closeButton: false,\r\n                closeOnClick: false\r\n            });\r\n\r\n            map.on('click', 'placeIDs', function(e){\r\n\r\n                var placeID = e.features[0].properties.placeID;           \r\n                var description = e.features[0].properties.description;\r\n                var movementID = e.features[0].properties.movementID;\r\n                var enter = e.features[0].properties.enter;\r\n                var leave = e.features[0].properties.leave;\r\n\r\n                // count += 1\r\n                // let m = that.props.movement.filter(x => x.id == movementID)\r\n                // let p = that.props.profile.filter(x => x.id == m[0].suspectId)\r\n                \r\n                that.props.dataRetrieved(movementID)\r\n\r\n                // if(Array.isArray(movementID)){\r\n\r\n                // }\r\n                // console.log(movementID)\r\n            });\r\n\r\n            map.on('mouseenter', 'placeIDs', function(e) {\r\n\r\n                // Change the cursor style as a UI indicator.\r\n                map.getCanvas().style.cursor = 'pointer';\r\n                \r\n                var coordinates = e.features[0].geometry.coordinates.slice();\r\n                var description = e.features[0].properties.description;\r\n\r\n                // Ensure that if the map is zoomed out such that multiple\r\n                // copies of the feature are visible, the popup appears\r\n                // over the copy being pointed to.\r\n                while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {\r\n                    coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;\r\n                }\r\n                \r\n                // Populate the popup and set its coordinates\r\n                // based on the feature found.\r\n                popup.setLngLat(coordinates).setHTML(description).addTo(map);\r\n            });\r\n                \r\n            map.on('mouseleave', 'placeIDs', function() {\r\n                map.getCanvas().style.cursor = '';\r\n                popup.remove();\r\n            });\r\n\r\n            counter += 1\r\n        }   \r\n    }\r\n\r\n    render(){\r\n\r\n        return(\r\n            <div style={{position:\"relative\",height:\"700px\", width:\"100%\"}}>\r\n                <div ref={el => this.mapContainer = el} style={{position:\"reletive\", width:\"inherit\", height:\"inherit\"}} id=\"map-field\"/>\r\n            </div>\r\n        )\r\n    }\r\n\r\n}\r\n\r\nexport default MainMap"]},"metadata":{},"sourceType":"module"}